input:
  label: "nats_service_time_utc"
  nats:
    urls:
      - ${NATS_URL}
    subject: ${INPUT_NATS_SUBJECT}
    auto_replay_nacks: false
    auth:
      user_credentials_file: ${NATS_USER_CREDENTIALS_FILE}

pipeline:
  processors:
    - label: set_server_time
      mapping: |
        root = {}
        root.now_since_epoch_ms = this.data

        root.search_lookback = "${S3CACHE_LOOKBACK}"
        root.search_lookback_step = "${S3CACHE_LOOKBACK_STEP}"
        root.search_prefix = "${S3CACHE_SEARCH_PREFIX}"
        root.file_time_extract = "${S3CACHE_FILE_TIME_FORMAT}"
        root.cache_update_interval = "${S3CACHE_UPDATE_INTERVAL}"

    - label: latest_s3_file
      http:
        url: "http://127.0.0.1:8123/asof_utc"
        verb: GET
        timeout: 10s
        headers:
          Content-Type: application/json
        parallel: false
        # rate_limit: s3_rate_limit

    - mapping: |
        root = this
        root.payload_type = "ndjson"
        root.s3.endpoint_url = env("AWS_ENDPOINT_URL")
        root.s3.region = env("AWS_DEFAULT_REGION")
        root.s3.bucket = env("AWS_BUCKET")

output:
  label: write_nats_output
  switch:
    cases:
      - check: this.is_new_file == true
        output:
          nats_jetstream:
            urls:
              - ${NATS_URL}
            subject: ${OUTPUT_NATS_SUBJECT}
            headers: {}
            metadata:
              include_prefixes: []
              include_patterns: []
            max_in_flight: 4
            auth:
              user_credentials_file: ${NATS_USER_CREDENTIALS_FILE}
      - check: this.is_new_file == false
        output:
          # stdout: {}
          drop: {}

logger:
  level: INFO
  add_timestamp: true

metrics:
  prometheus: {}

rate_limit_resources:
  - label: s3_rate_limit
    local:
      count: 1
      interval: 10s

